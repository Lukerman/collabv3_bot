"""
AI handlers for CollaLearn bot.
Handles AI-powered features: summary, explain, and quiz generation.
"""

import logging
from telegram import Update
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from config import config
from db import Database
from ai_client import ai_client
from utils.text_extract import extract_text_from_file
from utils.validator import validate_ai_enabled

logger = logging.getLogger(__name__)


async def summary_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /summary command.
    Generate a summary of replied message or file.
    
    Args:
        update: Telegram update object
        context: Callback context
    """
    try:
        message = update.message
        chat = update.effective_chat
        user = update.effective_user
        
        # Only in groups
        if chat.type not in ["group", "supergroup"]:
            await message.reply_text("This command only works in groups.")
            return
        
        # Check if AI is enabled
        db = Database()
        group = db.get_group(chat.id)
        
        if not group:
            await message.reply_text("‚ö†Ô∏è Group not registered. Use /start first.")
            return
        
        settings = group.get("settings", {})
        
        if not validate_ai_enabled(settings, "summarization_enabled"):
            await message.reply_text(
                "ü§ñ AI summarization is disabled in this group.\n"
                "Contact group admin to enable it."
            )
            return
        
        # Must be a reply
        if not message.reply_to_message:
            await message.reply_text(
                "‚ùå Please reply to a message or file with `/summary`",
                parse_mode=ParseMode.MARKDOWN
            )
            return
        
        replied_msg = message.reply_to_message
        
        # Extract text
        text = None
        
        if replied_msg.text:
            text = replied_msg.text
        elif replied_msg.caption:
            text = replied_msg.caption
        elif replied_msg.document or replied_msg.photo:
            # Download and extract from file
            processing_msg = await message.reply_text("‚è≥ Processing file...")
            
            try:
                if replied_msg.document:
                    file_obj = replied_msg.document
                    file_name = file_obj.file_name
                    mime_type = file_obj.mime_type
                elif replied_msg.photo:
                    file_obj = replied_msg.photo[-1]
                    file_name = "photo.jpg"
                    mime_type = "image/jpeg"
                
                file = await context.bot.get_file(file_obj.file_id)
                file_bytes = await file.download_as_bytearray()
                
                text = await extract_text_from_file(file_bytes, file_name, mime_type)
                
                await processing_msg.delete()
                
            except Exception as e:
                logger.error(f"Error extracting text: {e}")
                await processing_msg.edit_text("‚ö†Ô∏è Failed to extract text from file.")
                return
        
        if not text or len(text.strip()) < 50:
            await message.reply_text(
                "‚ö†Ô∏è Not enough text to summarize.\n"
                "Please provide more content."
            )
            return
        
        # Generate summary
        status_msg = await message.reply_text(
            "ü§ñ Generating summary...\n‚è≥ Please wait..."
        )
        
        summary = await ai_client.summarize_text(text)
        
        if not summary:
            await status_msg.edit_text(
                "‚ö†Ô∏è Failed to generate summary. Please try again later."
            )
            return
        
        # Log AI request
        db.log_ai_request(user.id, chat.id, "summary", text[:200])
        
        # Send summary
        response = f"üìù **Summary**\n\n{summary}\n\n"
        response += f"_Generated by AI ‚Ä¢ Requested by {user.mention_html()}_"
        
        await status_msg.edit_text(response, parse_mode=ParseMode.HTML)
        
        logger.info(f"Summary generated for user {user.id} in group {chat.id}")
        
    except Exception as e:
        logger.error(f"Error in summary_command: {e}", exc_info=True)
        await message.reply_text("‚ö†Ô∏è An error occurred while generating summary.")


async def explain_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /explain command.
    Provide detailed explanation of a topic or answer a question.
    
    Args:
        update: Telegram update object
        context: Callback context
    """
    try:
        message = update.message
        chat = update.effective_chat
        user = update.effective_user
        
        # Only in groups
        if chat.type not in ["group", "supergroup"]:
            await message.reply_text("This command only works in groups.")
            return
        
        # Check if AI is enabled
        db = Database()
        group = db.get_group(chat.id)
        
        if not group:
            await message.reply_text("‚ö†Ô∏è Group not registered. Use /start first.")
            return
        
        settings = group.get("settings", {})
        
        if not validate_ai_enabled(settings, "explanation_enabled"):
            await message.reply_text(
                "ü§ñ AI explanation is disabled in this group.\n"
                "Contact group admin to enable it."
            )
            return
        
        # Get question/topic
        question = None
        context_text = ""
        
        if context.args:
            question = " ".join(context.args)
        
        # If reply, use replied message as context
        if message.reply_to_message:
            replied_msg = message.reply_to_message
            
            if replied_msg.text:
                context_text = replied_msg.text
            elif replied_msg.caption:
                context_text = replied_msg.caption
            elif replied_msg.document or replied_msg.photo:
                processing_msg = await message.reply_text("‚è≥ Processing file...")
                
                try:
                    if replied_msg.document:
                        file_obj = replied_msg.document
                        file_name = file_obj.file_name
                        mime_type = file_obj.mime_type
                    elif replied_msg.photo:
                        file_obj = replied_msg.photo[-1]
                        file_name = "photo.jpg"
                        mime_type = "image/jpeg"
                    
                    file = await context.bot.get_file(file_obj.file_id)
                    file_bytes = await file.download_as_bytearray()
                    
                    context_text = await extract_text_from_file(file_bytes, file_name, mime_type)
                    
                    await processing_msg.delete()
                    
                except Exception as e:
                    logger.error(f"Error extracting text: {e}")
                    await processing_msg.edit_text("‚ö†Ô∏è Failed to extract text.")
                    return
        
        if not question and not context_text:
            await message.reply_text(
                "‚ùå **Usage:**\n\n"
                "‚Ä¢ `/explain <question>` - Ask a question\n"
                "‚Ä¢ Reply to a message with `/explain` - Get explanation\n"
                "‚Ä¢ Reply with `/explain <question>` - Ask about specific content",
                parse_mode=ParseMode.MARKDOWN
            )
            return
        
        # Generate explanation
        status_msg = await message.reply_text(
            "ü§ñ Generating explanation...\n‚è≥ Please wait..."
        )
        
        explanation = await ai_client.explain_text(context_text or question, question)
        
        if not explanation:
            await status_msg.edit_text(
                "‚ö†Ô∏è Failed to generate explanation. Please try again later."
            )
            return
        
        # Log AI request
        db.log_ai_request(user.id, chat.id, "explanation", (context_text or question)[:200])
        
        # Send explanation
        if question:
            response = f"üí° **Explanation: {question}**\n\n"
        else:
            response = f"üí° **Explanation**\n\n"
        
        response += f"{explanation}\n\n"
        response += f"_Generated by AI ‚Ä¢ Requested by {user.mention_html()}_"
        
        await status_msg.edit_text(response, parse_mode=ParseMode.HTML)
        
        logger.info(f"Explanation generated for user {user.id} in group {chat.id}")
        
    except Exception as e:
        logger.error(f"Error in explain_command: {e}", exc_info=True)
        await message.reply_text("‚ö†Ô∏è An error occurred while generating explanation.")


async def quiz_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /quiz command.
    Generate multiple choice questions from content.
    
    Args:
        update: Telegram update object
        context: Callback context
    """
    try:
        message = update.message
        chat = update.effective_chat
        user = update.effective_user
        
        # Only in groups
        if chat.type not in ["group", "supergroup"]:
            await message.reply_text("This command only works in groups.")
            return
        
        # Check if AI is enabled
        db = Database()
        group = db.get_group(chat.id)
        
        if not group:
            await message.reply_text("‚ö†Ô∏è Group not registered. Use /start first.")
            return
        
        settings = group.get("settings", {})
        
        if not validate_ai_enabled(settings, "quiz_enabled"):
            await message.reply_text(
                "ü§ñ AI quiz generation is disabled in this group.\n"
                "Contact group admin to enable it."
            )
            return
        
        # Get number of questions
        question_count = 5  # Default
        
        if context.args:
            try:
                question_count = int(context.args[0])
                question_count = min(max(question_count, 1), 10)  # Limit 1-10
            except ValueError:
                pass
        
        # Must be a reply
        if not message.reply_to_message:
            await message.reply_text(
                "‚ùå **Usage:** Reply to a file or message with `/quiz [number]`\n\n"
                "**Example:** `/quiz 5` (generates 5 questions)",
                parse_mode=ParseMode.MARKDOWN
            )
            return
        
        replied_msg = message.reply_to_message
        
        # Extract text
        text = None
        
        if replied_msg.text:
            text = replied_msg.text
        elif replied_msg.caption:
            text = replied_msg.caption
        elif replied_msg.document or replied_msg.photo:
            processing_msg = await message.reply_text("‚è≥ Processing file...")
            
            try:
                if replied_msg.document:
                    file_obj = replied_msg.document
                    file_name = file_obj.file_name
                    mime_type = file_obj.mime_type
                elif replied_msg.photo:
                    file_obj = replied_msg.photo[-1]
                    file_name = "photo.jpg"
                    mime_type = "image/jpeg"
                
                file = await context.bot.get_file(file_obj.file_id)
                file_bytes = await file.download_as_bytearray()
                
                text = await extract_text_from_file(file_bytes, file_name, mime_type)
                
                await processing_msg.delete()
                
            except Exception as e:
                logger.error(f"Error extracting text: {e}")
                await processing_msg.edit_text("‚ö†Ô∏è Failed to extract text from file.")
                return
        
        if not text or len(text.strip()) < 100:
            await message.reply_text(
                "‚ö†Ô∏è Not enough content to generate quiz.\n"
                "Please provide more detailed content."
            )
            return
        
        # Generate quiz
        status_msg = await message.reply_text(
            f"ü§ñ Generating {question_count} quiz questions...\n‚è≥ Please wait..."
        )
        
        quiz = await ai_client.generate_quiz(text, question_count)
        
        if not quiz:
            await status_msg.edit_text(
                "‚ö†Ô∏è Failed to generate quiz. Please try again later."
            )
            return
        
        # Log AI request
        db.log_ai_request(user.id, chat.id, "quiz", text[:200])
        
        # Send quiz
        response = f"üìù **Practice Quiz ({question_count} Questions)**\n\n"
        response += f"{quiz}\n\n"
        response += f"_Generated by AI ‚Ä¢ Requested by {user.mention_html()}_"
        
        # Split if too long
        if len(response) > 4000:
            parts = [response[i:i+4000] for i in range(0, len(response), 4000)]
            await status_msg.delete()
            for part in parts:
                await message.reply_text(part, parse_mode=ParseMode.HTML)
        else:
            await status_msg.edit_text(response, parse_mode=ParseMode.HTML)
        
        logger.info(f"Quiz generated for user {user.id} in group {chat.id}")
        
    except Exception as e:
        logger.error(f"Error in quiz_command: {e}", exc_info=True)
        await message.reply_text("‚ö†Ô∏è An error occurred while generating quiz.")